// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package ticketDB

import (
	"context"
	"database/sql"
	"time"
)

const browseEvents = `-- name: BrowseEvents :many
SELECT e.id, e.name, e.description, e.location, e.start_time, e.end_time, e.created_at, ei.image_key
FROM events e
JOIN event_images ei ON e.id = ei.event_id AND ei.is_primary = true
WHERE
    ($1::text = '' OR e.name ILIKE '%' || $1 || '%') AND
    ($2::text = '' OR e.location ILIKE '%' || $2 || '%') AND
    ($3::timestamp = '0001-01-01 00:00:00' OR e.start_time >= $3) AND
    ($4::timestamp = '0001-01-01 00:00:00' OR e.start_time <= $4) AND
    (
        $5::timestamp = '0001-01-01 00:00:00' OR
        e.start_time > $5::timestamp OR
        (e.start_time = $5::timestamp AND e.id > $6::int)
        )
ORDER BY e.start_time ASC, e.id ASC
    LIMIT $7
`

type BrowseEventsParams struct {
	EventName  string    `json:"event_name"`
	Location   string    `json:"location"`
	StartDate  time.Time `json:"start_date"`
	EndDate    time.Time `json:"end_date"`
	CursorTime time.Time `json:"cursor_time"`
	CursorID   int32     `json:"cursor_id"`
	PageSize   int32     `json:"page_size"`
}

type BrowseEventsRow struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Location    string         `json:"location"`
	StartTime   time.Time      `json:"start_time"`
	EndTime     time.Time      `json:"end_time"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	ImageKey    string         `json:"image_key"`
}

func (q *Queries) BrowseEvents(ctx context.Context, arg BrowseEventsParams) ([]BrowseEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, browseEvents,
		arg.EventName,
		arg.Location,
		arg.StartDate,
		arg.EndDate,
		arg.CursorTime,
		arg.CursorID,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BrowseEventsRow
	for rows.Next() {
		var i BrowseEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.ImageKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteEventImage = `-- name: DeleteEventImage :exec
DELETE FROM event_images
WHERE image_key = $1
`

func (q *Queries) DeleteEventImage(ctx context.Context, imageKey string) error {
	_, err := q.db.ExecContext(ctx, deleteEventImage, imageKey)
	return err
}

const getEventCategories = `-- name: GetEventCategories :many
SELECT id, event_id, name, category_type, price, book_type, total_capacity, available_stock FROM event_categories
WHERE event_id = $1
`

func (q *Queries) GetEventCategories(ctx context.Context, eventID int32) ([]EventCategory, error) {
	rows, err := q.db.QueryContext(ctx, getEventCategories, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventCategory
	for rows.Next() {
		var i EventCategory
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.CategoryType,
			&i.Price,
			&i.BookType,
			&i.TotalCapacity,
			&i.AvailableStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventCategoryById = `-- name: GetEventCategoryById :one
SELECT id, event_id, name, category_type, price, book_type, total_capacity, available_stock FROM event_categories
WHERE id = $1
`

func (q *Queries) GetEventCategoryById(ctx context.Context, id int32) (EventCategory, error) {
	row := q.db.QueryRowContext(ctx, getEventCategoryById, id)
	var i EventCategory
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.CategoryType,
		&i.Price,
		&i.BookType,
		&i.TotalCapacity,
		&i.AvailableStock,
	)
	return i, err
}

const getEventDetails = `-- name: GetEventDetails :one
SELECT id, name, description, location, start_time, end_time, created_at FROM events
WHERE id = $1
`

func (q *Queries) GetEventDetails(ctx context.Context, id int32) (Event, error) {
	row := q.db.QueryRowContext(ctx, getEventDetails, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
	)
	return i, err
}

const getEventImages = `-- name: GetEventImages :many
SELECT id, event_id, image_key, is_primary, display_order, created_at FROM event_images
WHERE event_id = $1
ORDER BY display_order
`

func (q *Queries) GetEventImages(ctx context.Context, eventID int32) ([]EventImage, error) {
	rows, err := q.db.QueryContext(ctx, getEventImages, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventImage
	for rows.Next() {
		var i EventImage
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.ImageKey,
			&i.IsPrimary,
			&i.DisplayOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketSeatAndEventCat = `-- name: GetTicketSeatAndEventCat :one
SELECT id, event_category_id, seat_number, status, reserved_until, version FROM tickets
WHERE event_category_id = $1 AND seat_number = $2
LIMIT 1
`

type GetTicketSeatAndEventCatParams struct {
	EventCategoryID int32          `json:"event_category_id"`
	SeatNumber      sql.NullString `json:"seat_number"`
}

func (q *Queries) GetTicketSeatAndEventCat(ctx context.Context, arg GetTicketSeatAndEventCatParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, getTicketSeatAndEventCat, arg.EventCategoryID, arg.SeatNumber)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.EventCategoryID,
		&i.SeatNumber,
		&i.Status,
		&i.ReservedUntil,
		&i.Version,
	)
	return i, err
}

const insertBooking = `-- name: InsertBooking :one
INSERT INTO bookings (ticket_id, status)
VALUES ($1, $2)
    RETURNING id, ticket_id, status, created_at, user_id, event_id, event_category_id
`

type InsertBookingParams struct {
	TicketID sql.NullInt32 `json:"ticket_id"`
	Status   string        `json:"status"`
}

func (q *Queries) InsertBooking(ctx context.Context, arg InsertBookingParams) (Booking, error) {
	row := q.db.QueryRowContext(ctx, insertBooking, arg.TicketID, arg.Status)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.Status,
		&i.CreatedAt,
		&i.UserID,
		&i.EventID,
		&i.EventCategoryID,
	)
	return i, err
}

const insertEvent = `-- name: InsertEvent :one
INSERT INTO events (name, description, location, start_time, end_time)
VALUES ($1, $2, $3, $4, $5)
    RETURNING id, name, description, location, start_time, end_time, created_at
`

type InsertEventParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Location    string         `json:"location"`
	StartTime   time.Time      `json:"start_time"`
	EndTime     time.Time      `json:"end_time"`
}

func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, insertEvent,
		arg.Name,
		arg.Description,
		arg.Location,
		arg.StartTime,
		arg.EndTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
	)
	return i, err
}

const insertEventCategory = `-- name: InsertEventCategory :one
INSERT INTO event_categories (event_id, name, category_type, price, book_type, total_capacity, available_stock)
VALUES ($1, $2, $3, $4, $5, $6, $7)
    RETURNING id, event_id, name, category_type, price, book_type, total_capacity, available_stock
`

type InsertEventCategoryParams struct {
	EventID        int32          `json:"event_id"`
	Name           string         `json:"name"`
	CategoryType   sql.NullString `json:"category_type"`
	Price          string         `json:"price"`
	BookType       string         `json:"book_type"`
	TotalCapacity  int32          `json:"total_capacity"`
	AvailableStock int32          `json:"available_stock"`
}

func (q *Queries) InsertEventCategory(ctx context.Context, arg InsertEventCategoryParams) (EventCategory, error) {
	row := q.db.QueryRowContext(ctx, insertEventCategory,
		arg.EventID,
		arg.Name,
		arg.CategoryType,
		arg.Price,
		arg.BookType,
		arg.TotalCapacity,
		arg.AvailableStock,
	)
	var i EventCategory
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.CategoryType,
		&i.Price,
		&i.BookType,
		&i.TotalCapacity,
		&i.AvailableStock,
	)
	return i, err
}

const insertEventImage = `-- name: InsertEventImage :one
INSERT INTO event_images (event_id, image_key, is_primary, display_order)
VALUES ($1, $2, $3, $4)
    RETURNING id, event_id, image_key, is_primary, display_order, created_at
`

type InsertEventImageParams struct {
	EventID      int32         `json:"event_id"`
	ImageKey     string        `json:"image_key"`
	IsPrimary    sql.NullBool  `json:"is_primary"`
	DisplayOrder sql.NullInt32 `json:"display_order"`
}

func (q *Queries) InsertEventImage(ctx context.Context, arg InsertEventImageParams) (EventImage, error) {
	row := q.db.QueryRowContext(ctx, insertEventImage,
		arg.EventID,
		arg.ImageKey,
		arg.IsPrimary,
		arg.DisplayOrder,
	)
	var i EventImage
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ImageKey,
		&i.IsPrimary,
		&i.DisplayOrder,
		&i.CreatedAt,
	)
	return i, err
}

const insertTicket = `-- name: InsertTicket :one
INSERT INTO tickets (event_category_id, seat_number, status, reserved_until)
VALUES ($1, $2, $3, $4)
    RETURNING id, event_category_id, seat_number, status, reserved_until, version
`

type InsertTicketParams struct {
	EventCategoryID int32          `json:"event_category_id"`
	SeatNumber      sql.NullString `json:"seat_number"`
	Status          sql.NullString `json:"status"`
	ReservedUntil   sql.NullTime   `json:"reserved_until"`
}

func (q *Queries) InsertTicket(ctx context.Context, arg InsertTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, insertTicket,
		arg.EventCategoryID,
		arg.SeatNumber,
		arg.Status,
		arg.ReservedUntil,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.EventCategoryID,
		&i.SeatNumber,
		&i.Status,
		&i.ReservedUntil,
		&i.Version,
	)
	return i, err
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE tickets
SET status = $1, reserved_until = $2
WHERE event_category_id = $3 AND seat_number = $4
RETURNING id
`

type UpdateTicketStatusParams struct {
	Status          sql.NullString `json:"status"`
	ReservedUntil   sql.NullTime   `json:"reserved_until"`
	EventCategoryID int32          `json:"event_category_id"`
	SeatNumber      sql.NullString `json:"seat_number"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatus,
		arg.Status,
		arg.ReservedUntil,
		arg.EventCategoryID,
		arg.SeatNumber,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
